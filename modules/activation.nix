{ config, pkgs, lib, theme, shellapps, ... }:

let
  homeDirectory = config.home.homeDirectory;
in {
  # Application Management
  # Note: Handled natively by home-manager 25.11+
  # Apps are automatically available in ~/Applications/Home Manager Apps

  home.activation = {
    # gitIgnoreOverconfigChanges
    # Purpose: Makes git ignore changes to overconfig.nix after home-manager activation
    # Why: Allows machine-specific settings in overconfig.nix without polluting git status
    # When: After writeBoundary (after files are written to disk)
    gitIgnoreOverconfigChanges = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      $DRY_RUN_CMD ${pkgs.git}/bin/git -C ~/.config/nixpkgs update-index --assume-unchanged overconfig.nix
    '';

    # claudeSettings
    # Purpose: Creates Claude Code settings.json with configured hooks
    # Why: Integrates Claude Code with notification, completion, and formatting hooks
    # When: After writeBoundary (after files are written to disk)
    # Dependencies: Requires shellapps for hook commands
    claudeSettings = let
      settingsContent = {
        hooks = {
          Notification = [{
            hooks = [{
              type = "command";
              command = "${shellapps.claude-notification-hook}/bin/claude-notification-hook";
            }];
          }];
          Stop = [{
            hooks = [{
              type = "command";
              command = "${shellapps.claude-complete-hook}/bin/claude-complete-hook";
            }];
          }];
          PostToolUse = [{
            matcher = "Edit|MultiEdit|Write";
            hooks = [{
              type = "command";
              command = "${shellapps.claude-csharp-format-hook}/bin/claude-csharp-format-hook";
            }];
          }];
        };
      };
      claudeSettingsJson = pkgs.runCommand "claude-settings.json" {} ''
        echo '${builtins.toJSON settingsContent}' | ${pkgs.jq}/bin/jq . > $out
      '';
    in lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      $DRY_RUN_CMD mkdir -p ~/.claude
      $DRY_RUN_CMD ln -sf ${claudeSettingsJson} ~/.claude/settings.json
    '';

    # claudeGlobal
    # Purpose: Copies global Claude Code configuration to ~/.claude
    # Why: Provides global Claude Code settings and custom slash commands
    # When: After writeBoundary (after files are written to disk)
    # Note: Contents from claude-global/ directory (CLAUDE.md and commands/)
    claudeGlobal = let
      claudeGlobalDir = ../claude-global;
    in lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      $DRY_RUN_CMD mkdir -p ~/.claude
      $DRY_RUN_CMD cp -rf ${claudeGlobalDir}/* ~/.claude/
    '';

    # precompileZshCompletions
    # Purpose: Pre-compiles Zsh completion dump file for faster shell startup
    # Why: Improves Zsh startup performance by using compiled completion cache
    # When: After writeBoundary (after files are written to disk)
    # Note: Creates ~/.zcompdump and ~/.zcompdump.zwc (compiled version)
    precompileZshCompletions = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      echo "Precompiling Zsh completions..."

      # Create a temporary file with the fpath setup
      $DRY_RUN_CMD cat > /tmp/zsh-compinit-setup <<'EOF'
      fpath=(
        ${homeDirectory}/.nix-profile/share/zsh/site-functions
        ${homeDirectory}/.nix-profile/share/zsh/vendor-completions
        /nix/var/nix/profiles/default/share/zsh/site-functions
        /nix/var/nix/profiles/default/share/zsh/vendor-completions
        $fpath
      )

      # Remove old dump files
      rm -f ${homeDirectory}/.zcompdump*

      # Generate new completion dump
      autoload -Uz compinit
      compinit -d ${homeDirectory}/.zcompdump

      # Compile the dump file for faster loading
      zcompile ${homeDirectory}/.zcompdump
      EOF

      # Run the setup
      $DRY_RUN_CMD ${pkgs.zsh}/bin/zsh /tmp/zsh-compinit-setup
      $DRY_RUN_CMD rm -f /tmp/zsh-compinit-setup

      echo "Zsh completions precompiled successfully"
    '';

    # generateDirenvHook
    # Purpose: Generates static direnv hook for Zsh
    # Why: Improves shell startup performance by avoiding dynamic direnv hook generation
    # When: After writeBoundary (after files are written to disk)
    # Note: Creates ~/.config/zsh/direnv-hook.zsh with pregenerated hook
    generateDirenvHook = let
      direnvHookFile = pkgs.writeText "direnv-hook.zsh" ''
        # Static direnv hook - pregenerated by Nix
        _direnv_hook() {
          trap -- "" SIGINT
          eval "$("${pkgs.direnv}/bin/direnv" export zsh)"
          trap - SIGINT
        }
        typeset -ag precmd_functions
        if (( ! ''${precmd_functions[(I)_direnv_hook]} )); then
          precmd_functions=(_direnv_hook $precmd_functions)
        fi
        typeset -ag chpwd_functions
        if (( ! ''${chpwd_functions[(I)_direnv_hook]} )); then
          chpwd_functions=(_direnv_hook $chpwd_functions)
        fi
      '';
    in lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      $DRY_RUN_CMD mkdir -p ${homeDirectory}/.config/zsh
      $DRY_RUN_CMD ln -sf ${direnvHookFile} ${homeDirectory}/.config/zsh/direnv-hook.zsh
    '';
  };
}
